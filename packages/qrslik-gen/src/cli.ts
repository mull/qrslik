#!/usr/bin/env node
import assert from "node:assert"
import { createPool, sql } from "slonik"
import path from "node:path"
import fs from "node:fs"
import { z } from "zod"
import { pascalCaseTableName } from "./utils"

const connection_string = process.env.POSTGRES_URL
assert(
  connection_string,
  "missing ENV variable POSTGRES_URL, example: postgressql://username:password@host:port/database_name"
)

const output_path = path.join(process.cwd(), "qrslik-gen.ts")
console.log(`[qrslik-code-gen]
  output_path: ${output_path}
`)

async function cli() {
  const pool = await createPool(connection_string)
  try {
    const introspection = await pool.any(sql.unsafe`
      SELECT * FROM 
      information_schema.tables
      WHERE table_schema = 'public'
    `)

    const schemas: string[] = []
    for (const entry of introspection) {
      if (entry.table_type !== "BASE TABLE") {
        console.info(`${entry.table_name} is not a base table, skipping.`)
        continue
      }

      const zod_schema_name = `${pascalCaseTableName(
        entry.table_name
      )}TableSchema`
      const MetaSchema = z.object({
        column_name: z.string(),
        is_nullable: z.boolean(),
        data_type: z.string(),
        udt_name: z.string(),
      })

      const table_meta = await pool.any(sql.type(MetaSchema)`
        -- SELECT column_name, is_nullable, data_type
        SELECT *
        FROM information_schema.columns
        WHERE table_schema = ${entry.table_schema} 
        AND   table_name = ${entry.table_name}
        ORDER BY ordinal_position ASC
      `)

      const shapes: string[] = []

      const udt_to_z_parser = (udt: string): string => {
        switch (udt) {
          case "int4":
          case "_int4":
            return "number()"
          case "uuid":
            return "string().uuid()"
          case "_text":
          case "text":
            return "string()"
          case "_bool":
          case "bool":
            return "boolean()"
          case "json":
            return "any()"

          default:
            throw `unknwon udt: ${udt}`
        }
      }

      for (const {
        column_name,
        is_nullable,
        data_type,
        udt_name,
      } of table_meta) {
        const parsers: string[] = []
        if (data_type === "ARRAY") {
          const udt = udt_to_z_parser(udt_name)
          parsers.push(`z.array(z.${udt})`)
        } else {
          const udt = udt_to_z_parser(udt_name)
          parsers.push(`z.${udt}`)
        }
        assert(
          parsers.length > 0,
          `found no type parser for ${column_name} ${data_type}`
        )

        if (is_nullable) {
          parsers.push("nullable()")
        }

        shapes.push(`  "${column_name}": ${parsers.join(".")}`)
      }

      const shape = `export const ${zod_schema_name} = z.object({\n${shapes.join(
        ",\n"
      )}\n})`
      schemas.push(shape)
    }

    const full_file = [
      `// this file was auto-generated by qrslik-gen`,
      `import { z } from 'zod'\n`,
      schemas.join("\n\n"),
      "",
    ].join("\n")

    fs.writeFileSync(output_path, full_file, {
      encoding: "utf-8",
      flag: "w+",
    })
    console.log(`All done!`)
  } finally {
    await pool.end()
  }
}

cli().catch(console.error)
